#ifndef __KRUSKAL_H__
#define __KRUSKAL_H__
#include "AdjMatrixUndirGraph.h"		// 邻接表无向网
#include "UFSets.h"		                // 并查类
#include "MineHeap.h"

// Kruskal边类
template <class ElemType, class WeightType>
class KruskalEdge
{
public:
	ElemType vertex1, vertex2;		// 边的顶点
	WeightType weight;				// 边的权值
	KruskalEdge(ElemType v1, ElemType v2, WeightType w);	// 构造函数
	KruskalEdge(){};	            // 构造函数
	KruskalEdge<ElemType, WeightType> &operator =(const KruskalEdge<ElemType, WeightType> &Ed); // 赋值语句重载
	bool operator <=(const KruskalEdge<ElemType, WeightType> &Ed);		// 重载<=关系运算 
	bool operator >(const KruskalEdge<ElemType, WeightType> &Ed);		// 重载>关系运算
};

template <class ElemType, class WeightType>
KruskalEdge<ElemType, WeightType>::KruskalEdge(ElemType v1, ElemType v2, WeightType w)
// 操作结果: 由顶点v1、v2和权w构造边――构造函数
{	// 构造函数
	vertex1 = v1;					// 顶点vertex1
	vertex2 = v2;					// 顶点vertex2
	weight = w;						// 权weight
}

template <class ElemType, class WeightType>
bool KruskalEdge<ElemType, WeightType>::operator <= (const KruskalEdge<ElemType, WeightType> &Ed)
// 操作结果：重载<=关系运算
{
	return (weight <= Ed.weight);
}

template <class ElemType, class WeightType>
bool KruskalEdge<ElemType, WeightType>::operator > (const KruskalEdge<ElemType, WeightType> &Ed)
// 操作结果：重载>关系运算
{
	return (weight > Ed.weight);
}


template<class ElemType,  class WeightType>
KruskalEdge<ElemType, WeightType> &KruskalEdge<ElemType, WeightType>::operator = (const KruskalEdge<ElemType, WeightType> &Ed)
// 操作结果：将栈copy赋值给当前栈--赋值语句重载
{
	if (&Ed != this)	{
	   vertex1 = Ed.vertex1;					// 顶点vertex1
	   vertex2 = Ed.vertex2;					// 顶点vertex2
	   weight = Ed.weight;						// 权weight
	}
	return *this;
}


template <class ElemType>
int MiniSpanTreeKruskal(AdjMatrixUndirGraph<ElemType> &g)
// 初始条件：存在网g
// 操作结果：用Kruskal算法构造网g的最小代价生成树
{
	int count, VexNum = g.GetVexNum();
    KruskalEdge<ElemType, int> KEdge;
 	MinHeap<KruskalEdge<ElemType, int> > ha(g.GetEdgeNum());
    ElemType  *kVex, v1, v2;
	kVex = new ElemType[VexNum];	// 定义顶点数组,存储顶点信息 
	for (int i = 0; i < VexNum; i++)
	    g.GetElem(i, kVex[i]);
	UFSets<ElemType> f(kVex,VexNum);// 根据顶点数组构造并查集 
	for (int v = 0; v < g.GetVexNum(); v++)
		for (int u = g.FirstAdjVex(v); u >= 0; u = g.NextAdjVex(v, u))
			if (v < u)			{	// 将v < u的边插入到最小堆 
                g.GetElem(v, v1); 
                g.GetElem(u, v2);
                KEdge.vertex1 = v1;
                KEdge.vertex2 = v2;
                KEdge.weight = g.GetWeight(v,u);
				ha.Insert(KEdge);
			}
	count = 0;					    // 表示已经挑选的边数
	int cost = 0;
	int _weight;
	while (count < VexNum - 1)	{	
        ha.DeleteTop(KEdge);        // 从堆顶取一条边
		v1 = KEdge.vertex1;
        v2 = KEdge.vertex2;
		_weight = KEdge.weight;
		if (f.Differ(v1, v2))	{	// 边所依附的两顶点不在同一棵树上
			cout << "边:( " << v1 << ", " << v2 << " ) 权:" << _weight << endl ; // 输出边及权值
			cost += _weight;
			f.Union(v1, v2);		// 将两个顶点所在的树合并成一棵树
			count++;
		}
		
	}
	cout << "公路总长:" << cost << endl;
	return cost;
}

template <class ElemType>
void DFSTraverse(const AdjMatrixUndirGraph<ElemType> &g, void (*Visit)(const ElemType &))
// 初始条件：存在图g
// 操作结果：对无向图g进行深度优先遍历
{
	int v;
	for (v = 0; v < g.GetVexNum(); v++)
		g.SetTag(v, UNVISITED);// 对每个顶点设置未访问标志

	for (v = 0; v < g.GetVexNum(); v++)
		
		if (g.GetTag(v) == UNVISITED)
			DFS(g, v , Visit);// 从尚未访问的顶点v开始进行深度优先搜索 
}

template <class ElemType>
void DFS(const AdjMatrixUndirGraph<ElemType> &g, int v, void (*Visit)(const ElemType &))
// 初始条件：存在图g
// 操作结果：从顶点v出发进行深度优先搜索
{	
	ElemType e;	
	g.SetTag(v, VISITED);		// 设置顶点v已访问标志
	g.GetElem(v, e);			// 取顶点v的数据元素值 
	Visit(e);					// 访问顶点v
	for (int w = g.FirstAdjVex(v); w != -1; w = g.NextAdjVex(v, w))
		if (g.GetTag(w) == UNVISITED)
			DFS(g, w , Visit);	// 从v的尚未访问过的邻接顶点w开始进行深度优先搜索
}

#endif

